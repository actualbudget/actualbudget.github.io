"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5583],{36826:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"api/actual-ql/index","title":"ActualQL Overview","description":"Introduction","source":"@site/docs/api/actual-ql/index.md","sourceDirName":"api/actual-ql","slug":"/api/actual-ql/","permalink":"/docs/api/actual-ql/","draft":false,"unlisted":false,"editUrl":"https://github.com/actualbudget/actual/tree/master/packages/docs/docs/api/actual-ql/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"API Reference","permalink":"/docs/api/reference"},"next":{"title":"ActualQL Functions","permalink":"/docs/api/actual-ql/functions"}}');var s=t(31085),i=t(71184);const r={},o="ActualQL Overview",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Running a Query",id:"running-a-query",level:2},{value:"Specify Split Transaction Behavior",id:"specify-split-transaction-behavior",level:2},{value:"Searching Transactions",id:"searching-transactions",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"actualql-overview",children:"ActualQL Overview"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["ActualQL is a new query language introduced in 0.0.129. This allows you to query data any way you like. For example, previously we provided a ",(0,s.jsx)(n.code,{children:"filterTransactions"})," method that let you search transactions, but its behavior was baked into the backend. You couldn't change how transactions were sorted, search certain fields specifically, or sum the total amount."]}),"\n",(0,s.jsx)(n.p,{children:"ActualQL provides a lightweight syntax for querying data. It looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"q('transactions')\n  .filter({\n    'category.name': 'Food',\n    date: '2021-02-20',\n  })\n  .select(['id', 'date', 'amount']);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above query would return the ",(0,s.jsx)(n.code,{children:"id"}),", ",(0,s.jsx)(n.code,{children:"date"}),", and ",(0,s.jsx)(n.code,{children:"amount"})," of all transactions with the ",(0,s.jsx)(n.code,{children:"Food"})," category on ",(0,s.jsx)(n.code,{children:"2021-02-20"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Currently the query language is mostly undocumented, but more docs will come soon. Most of Actual uses ActualQL, so you have access to the same functionality that Actual has."}),"\n",(0,s.jsx)(n.p,{children:"Until we have better docs, here are few things you can do with ActualQL."}),"\n",(0,s.jsx)(n.h2,{id:"running-a-query",children:"Running a Query"}),"\n",(0,s.jsxs)(n.p,{children:["You construct a query with ",(0,s.jsx)(n.code,{children:"q"})," and run it with ",(0,s.jsx)(n.code,{children:"runQuery"}),". The result is an object with a ",(0,s.jsx)(n.code,{children:"data"})," prop. An example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let { q, runQuery } = require('@actual-app/api');\n\nlet { data } = await runQuery(q('transactions').select('*'));\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"data"})," will be an array of all the transactions in the system."]}),"\n",(0,s.jsx)(n.h2,{id:"specify-split-transaction-behavior",children:"Specify Split Transaction Behavior"}),"\n",(0,s.jsx)(n.p,{children:"Split transactions complicate things: when you sum transaction amounts, do you sum up all the subtransactions or do you just use the top-level transaction? When selecting transactions, which ones do you want?"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"transactions"})," table provides two different interfaces for transaction data to help with this. You can configure the type of data to return using ",(0,s.jsx)(n.code,{children:"options"})," and passing a ",(0,s.jsx)(n.code,{children:"splits"})," option:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"q('transactions').select('*').options({ splits: 'inline' });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There are two different options for ",(0,s.jsx)(n.code,{children:"splits"}),": ",(0,s.jsx)(n.code,{children:"inline"})," or ",(0,s.jsx)(n.code,{children:"grouped"}),(0,s.jsx)("super",{children:"*"}),". ",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"inline"})," is the default"]}),', and will not return the "parent" transaction of a split transaction. It will only show you subtransactions of split transaction, and the result is a flat array of transactions. This lets you sum all the amounts of transactions and by default it will ignore the "parent" transaction.']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"grouped"})," always returns the full split transaction (parent and subtransaction), no matter which part of it matched a filter. The returned data is also grouped so that transactions have a ",(0,s.jsx)(n.code,{children:"subtransactions"})," property that lists them."]}),"\n",(0,s.jsx)(n.p,{children:"These two options give you full control over how you want to handle split transactions."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["* There is a third option as well, ",(0,s.jsx)(n.code,{children:"all"}),", which returns both transactions and subtransactions in a flat list. You only need this if doing something advanced."]})}),"\n",(0,s.jsx)(n.h2,{id:"searching-transactions",children:"Searching Transactions"}),"\n",(0,s.jsxs)(n.p,{children:["Calling ",(0,s.jsx)(n.code,{children:"filter"})," applies conditions to the query; only data that matches the given filters will be returned."]}),"\n",(0,s.jsxs)(n.p,{children:["The keys of a filter object are the names of the fields (see ",(0,s.jsx)(n.a,{href:"/docs/api/reference#transaction",children:"Transaction"}),') and the values are the condition. By default, it will perform an "is equal" but you can also provide various operators. An example:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"q('transactions')\n  .filter({\n    'category.name': 'Food',\n    date: { $gte: '2021-01-01' },\n  })\n  .select('*');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"$gte"})," operator on ",(0,s.jsx)(n.code,{children:"date"})," returns transactions on or after ",(0,s.jsx)(n.code,{children:"2021-01-01"}),". Available operators are ",(0,s.jsx)(n.code,{children:"$eq"}),", ",(0,s.jsx)(n.code,{children:"$lt"}),", ",(0,s.jsx)(n.code,{children:"$lte"}),", ",(0,s.jsx)(n.code,{children:"$gt"}),", ",(0,s.jsx)(n.code,{children:"$gte"}),", ",(0,s.jsx)(n.code,{children:"$ne"}),", ",(0,s.jsx)(n.code,{children:"$oneof"}),", ",(0,s.jsx)(n.code,{children:"$regex"}),", ",(0,s.jsx)(n.code,{children:"$like"}),", and ",(0,s.jsx)(n.code,{children:"$notlike"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you pass an array to a field, it will combine the conditions with ",(0,s.jsx)(n.code,{children:"$and"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"q('transactions')\n  .filter({\n    date: [{ $gte: '2021-01-01' }, { $lte: '2021-12-31' }],\n  })\n  .select('*');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is the same query but restricts it to transactions between ",(0,s.jsx)(n.code,{children:"2021-01-01"})," and ",(0,s.jsx)(n.code,{children:"2021-12-31"}),". This could have been written as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"q('transactions')\n  .filter({\n    $and: [{ date: { $gte: '2021-01-01' } }, { date: { $lte: '2021-12-31' } }],\n  })\n  .select('*');\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"$and"})," and ",(0,s.jsx)(n.code,{children:"$or"})," takes an array and combines multiple conditions. For example, you could get transactions on multiple dates like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"q('transactions')\n  .filter({\n    $or: [{ date: '2021-01-01' }, { date: '2021-01-02' }],\n  })\n  .select('*');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above will return transactions on ",(0,s.jsx)(n.code,{children:"2021-01-01"})," ",(0,s.jsx)(n.strong,{children:"or"})," ",(0,s.jsx)(n.code,{children:"2021-01-02"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(14041);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);